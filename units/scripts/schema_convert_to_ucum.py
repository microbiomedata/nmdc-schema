#!/usr/bin/env python3
"""
Generate input for process.py from NMDC schema data only.

This script demonstrates that the input for process.py can be generated
completely deterministically from schema-centric data without needing MongoDB data.

Prerequisites: Run this first to generate the preferred units report:
    cd src/scripts && python analyze_preferred_units.py

Data Sources (all schema-based):
1. preferred_units_report.tsv (generated by analyze_preferred_units.py)
2. UCUM validation rules (deterministic conversion logic)
3. Problem detection (pattern-based analysis of unit strings)

This replaces the original workflow that used MongoDB + MIxS + LLM processing.
"""

import pandas as pd
import re
import sys
from pathlib import Path
import click


def convert_preferred_unit_to_ucum(preferred_unit: str) -> tuple[str, int]:
    """
    Convert NMDC preferred_unit to UCUM notation and detect problems.
    
    This is completely deterministic based on unit string patterns - no LLM needed.
    """
    
    # Handle empty/missing units
    if not preferred_unit or preferred_unit.strip() == '':
        return '', 1
    
    preferred_unit = preferred_unit.strip()
    
    # Direct UCUM mappings for common single units
    direct_mappings = {
        'degree Celsius': 'Cel',
        'meter': 'm',
        'millimeter': 'mm', 
        'centimeter': 'cm',
        'kilometer': 'km',
        'gram': 'g',
        'kilogram': 'kg',
        'milligram': 'mg',
        'microgram': 'ug',
        'liter': 'L',
        'milliliter': 'mL',
        'second': 's',
        'minute': 'min',
        'hour': 'h',
        'day': 'd',
        'year': 'a',
        'percent': '%',
        'percentage': '%',
        'pH': 'pH',
        'Pascal': 'Pa',
        'atmosphere': 'atm',
        'square meter': 'm2',
        'cubic meter': 'm3',
        'square centimeter': 'cm2',
        'cubic centimeter': 'cm3',
    }
    
    # Check for direct mapping first
    if preferred_unit in direct_mappings:
        return direct_mappings[preferred_unit], 0
    
    # Problem patterns that indicate UCUM issues
    problem_patterns = [
        r'.*,.*',  # Multiple units separated by commas
        r'.*\|.*', # Multiple units separated by pipes  
        r'.*\[.*\].*',  # Bracketed units like [NTU], [pH]
        r'.*\bper\b.*\bper\b.*',  # Complex ratios like "per liter per hour"
        r'.*\bdegree\b.*(?!Celsius)',  # Non-standard degree units
        r'.*\bparts per\b.*',  # Parts per million/billion/etc
        r'.*\bmilli.*\s+per\s+.*',  # Complex compound units
        r'.*\bmicro.*\s+per\s+.*',  # Complex compound units
        r'.*\s+per\s+.*\s+per\s+.*',  # Triple ratios
        r'.*\bcft\b.*',  # Non-standard abbreviations
        r'.*\blb\b.*',   # Imperial units
        r'.*\binch\b.*', # Imperial units
        r'.*\bfeet\b.*', # Imperial units
        r'.*undefined.*',  # Undefined units
        r'.*not applicable.*',  # Not applicable
        r'.*\bAPI\b.*',  # Specialized scales
        r'.*mercury.*',  # Mercury-based pressure units
        r'.*formazin.*', # Turbidity units
        r'.*nephelometric.*', # Turbidity units
    ]
    
    # Check for problem patterns
    for pattern in problem_patterns:
        if re.match(pattern, preferred_unit, re.IGNORECASE):
            return preferred_unit, 1  # Keep original, mark as problem
    
    # Simple compound units that can be converted
    simple_compounds = {
        'milligram per liter': 'mg/L',
        'microgram per liter': 'ug/L', 
        'micromole per liter': 'umol/L',
        'gram per liter': 'g/L',
        'milligram per kilogram': 'mg/kg',
        'gram per kilogram': 'g/kg',
        'meter per second': 'm/s',
        'kilometer per hour': 'km/h',
        'gram per cubic meter': 'g/m3',
        'gram per cubic centimeter': 'g/cm3',
        'milligram per cubic meter': 'mg/m3',
        'Watt per square meter': 'W/m2',
        'joule per degree Celsius': 'J/Cel',
        'millimeter per year': 'mm/a',
        'cubic meter per day': 'm3/d',
        'cubic meter per second': 'm3/s',
        'liter per hour': 'L/h',
        'milliliter per hour': 'mL/h',
        'milliequivalent per liter': 'meq/L',
        'mole per liter': 'mol/L',
        'mole per liter per hour': 'mol/(L.h)',
        'millimole per liter': 'mmol/L',
        'micromole per kilogram': 'umol/kg',
        'nanogram per hour': 'ng/h',
        'nanogram per liter': 'ng/L',
        'millibar': 'mbar',
        'millimeter mercury': 'mm[Hg]',  # Will be flagged as problem
        'millivolt': 'mV',
        'milliSiemens per centimeter': 'mS/cm',
        'microEinstein per square meter per second': 'uE/(m2.s)',
        'rad': 'rad',
        'gray': 'Gy',
        'practical salinity unit': 'psu',
        'formazin turbidity unit': '[FTU]',  # Will be flagged as problem
        'formazin nephelometric units': '[FNU]',  # Will be flagged as problem
    }
    
    if preferred_unit in simple_compounds:
        # Check if the mapped unit has problem patterns
        mapped_unit = simple_compounds[preferred_unit]
        if '[' in mapped_unit or 'Hg' in mapped_unit:
            return mapped_unit, 1  # Mark as problem
        return mapped_unit, 0
    
    # If we can't map it cleanly, mark as problem
    return preferred_unit, 1


def expand_multi_unit_slots(df: pd.DataFrame) -> pd.DataFrame:
    """
    Expand slots that have multiple preferred units into separate rows.
    
    This handles the multi-unit case from the original workflow.
    """
    expanded_rows = []
    
    for _, row in df.iterrows():
        preferred_unit = row['preferred_unit']
        slot_name = row['slot_name']
        
        # Check for multiple units (comma or pipe separated)
        if ',' in preferred_unit or '|' in preferred_unit:
            # Split on both comma and pipe, clean whitespace
            units = re.split(r'[,|]', preferred_unit)
            units = [unit.strip() for unit in units if unit.strip()]
            
            # Create a row for each unit
            for unit in units:
                ucum_notation, problem = convert_preferred_unit_to_ucum(unit)
                expanded_rows.append({
                    'slot': slot_name,
                    'ucum_notation': ucum_notation,
                    'problem': problem,
                    'original_preferred_unit': preferred_unit,
                    'individual_unit': unit,
                    'context': row['context'],
                    'class_name': row['class_name'],
                    'description': row['description']
                })
        else:
            # Single unit
            ucum_notation, problem = convert_preferred_unit_to_ucum(preferred_unit)
            expanded_rows.append({
                'slot': slot_name,
                'ucum_notation': ucum_notation,
                'problem': problem,
                'original_preferred_unit': preferred_unit,
                'individual_unit': preferred_unit,
                'context': row['context'],
                'class_name': row['class_name'],
                'description': row['description']
            })
    
    return pd.DataFrame(expanded_rows)


@click.command()
@click.option('--input', type=click.Path(exists=True, path_type=Path), required=True,
              help='preferred_units_report.tsv from analyze.py')
@click.option('--output', type=click.Path(path_type=Path), required=True,
              help='TSV file with slot, ucum_notation, problem columns')
@click.option('--detailed', type=click.Path(path_type=Path), 
              help='Output detailed metadata file')
@click.option('--quiet', '-q', is_flag=True, help='Suppress progress output')
def main(input: Path, output: Path, detailed: Path = None, quiet: bool = False):
    """Generate process.py input from NMDC schema preferred_unit annotations."""
    
    input_file = input
    output_file = output
    
    if not quiet:
        click.echo("Generating process.py input from NMDC schema...")
        click.echo("=" * 60)
    
    # Load the extracted data
    if not quiet:
        click.echo(f"Loading preferred units data from {input_file}...")
    
    schema_df = pd.read_csv(input_file, sep='\t')
    if not quiet:
        click.echo(f"Found {len(schema_df)} slots with preferred_unit annotations")
    
    # Expand multi-unit slots and convert to UCUM
    if not quiet:
        click.echo("Converting preferred units to UCUM notation...")
    expanded_df = expand_multi_unit_slots(schema_df)
    
    # Create the minimal input file (only required columns)
    required_cols = ['slot', 'ucum_notation', 'problem']
    minimal_df = expanded_df[required_cols].copy()
    
    # Write output file
    minimal_df.to_csv(output_file, sep='\t', index=False)
    if not quiet:
        click.echo(f"Generated: {output_file} ({len(minimal_df)} rows)")
    
    # Write detailed file if requested
    if detailed:
        expanded_df.to_csv(detailed, sep='\t', index=False)
        if not quiet:
            click.echo(f"Generated: {detailed} ({len(expanded_df)} rows with metadata)")
    
    if not quiet:
        # Show summary
        click.echo(f"\nSummary:")
        click.echo(f"Total slot-unit combinations: {len(expanded_df)}")
        click.echo(f"Unique slots: {expanded_df['slot'].nunique()}")
        click.echo(f"Problem units (need fixing): {expanded_df['problem'].sum()}")
        click.echo(f"Clean UCUM units: {(expanded_df['problem'] == 0).sum()}")
        
        # Count single vs multi-unit slots
        slot_counts = expanded_df.groupby('slot').size()
        single_unit_slots = (slot_counts == 1).sum()
        multi_unit_slots = (slot_counts > 1).sum()
        click.echo(f"Single-unit slots: {single_unit_slots}")
        click.echo(f"Multi-unit slots: {multi_unit_slots}")


if __name__ == "__main__":
    main()